use cb_common::commit::client::SignerClient;
use cb_common::config::StartSignerConfig;
use cb_common::types::{BlsPublicKey, Jwt, ModuleId};
use cb_common::utils::{bls_pubkey_from_hex, random_jwt_secret};
use cb_signer::service::SigningService;
use eyre::Result;
use inclusion::constants::INCLUSION_CONSTRAINT_TYPE;
use serde::Deserialize;
use tokio::time::sleep;
use toml_edit::DocumentMut;
use tracing::info;
use url::Url;

#[derive(Debug, Deserialize)]
pub struct SimulationConfig {
    // Chain name
    chain: String,

    // Log level
    log_level: String,

    // Module name
    gateway_module_name: String,
    proposer_module_name: String,

    // Module signing IDs
    gateway_module_signing_id: String,
    proposer_module_signing_id: String,

    // Database paths
    db_path: String,

    // --- Key paths ----
    gateway_default_bls_key: String,
    proxy_key_dir: String,
    keys_path: String,
    secrets_path: String,

    // --- Service URLs ----
    signer_host: String,
    signer_port: u16,
    beacon_mock_host: String,
    beacon_mock_port: u16,
    execution_client_host: String,
    execution_client_port: u16,
    gateway_host: String,
    gateway_port: u16,
    gateway_metrics_host: String,
    gateway_metrics_port: u16,
    relay_host: String,
    relay_port: u16,

    // Gateway specific
    delegation_check_interval_seconds: u64,

    // Proposer specific
    lookahead_check_interval_seconds: u64,

    // Relay specific
    lookahead_update_interval: u64,
    downstream_relay_url: String,

    // Spammer specific
    spammer_mode: String,
    spammer_interval_secs: u64,
    spammer_private_key: String,
    slasher_address: String,
}

impl SimulationConfig {
    pub fn new(config_path: &str) -> eyre::Result<Self> {
        let content = std::fs::read_to_string(config_path)?;
        let config: SimulationConfig = toml::from_str(&content)?;
        Ok(config)
    }

    pub fn setup_directories(&self) -> Result<()> {
        std::fs::create_dir_all("config/simulation")?;
        std::fs::create_dir_all(&self.db_path)?;
        std::fs::create_dir_all(&self.proxy_key_dir)?;
        std::fs::create_dir_all(&self.keys_path)?;
        std::fs::create_dir_all(&self.secrets_path)?;
        Ok(())
    }

    // Launch local signer server
    pub async fn load_cb_signer_config(
        &self,
        env_state: &SimulationEnv,
    ) -> Result<StartSignerConfig> {
        // load the signer .env file
        dotenv::from_filename(env_state.signer_env_file.clone().unwrap())?;

        // load the signer config
        Ok(StartSignerConfig::load_from_env()?)
    }

    // Launch signer client and generate proxy keys for gateway
    pub async fn launch_signer_client(&self, env_state: &SimulationEnv) -> Result<SignerClient> {
        let signer_url = env_state.signer_url.clone().unwrap();
        let client = SignerClient::new(
            signer_url,
            None,
            Jwt(env_state.gateway_jwt.clone().unwrap().to_string()),
            ModuleId(env_state.gateway_module_id.clone().unwrap().to_string()),
        )?;
        Ok(client)
    }

    // Build a signer client and generate proxy keys for gateway
    pub async fn generate_gateway_proxy_keys(
        &self,
        env_state: &SimulationEnv,
    ) -> Result<(BlsPublicKey, String)> {
        let mut client = self.launch_signer_client(env_state).await?;

        let gateway_bls_key = bls_pubkey_from_hex(self.gateway_default_bls_key.as_str())?;

        let bls_proxy = client
            .generate_proxy_key_bls(gateway_bls_key.clone())
            .await?;
        println!("BLS proxy: {:?}", bls_proxy);
        let ecdsa_proxy = client.generate_proxy_key_ecdsa(gateway_bls_key).await?;
        println!("ECDSA proxy: {:?}", ecdsa_proxy);

        Ok((
            bls_proxy.message.proxy,
            ecdsa_proxy.message.proxy.to_checksum(None),
        ))
    }

    pub fn cb_config(&self) -> String {
        format!(
            r#"# This file is automatically generated by the simulation-setup binary
# It contains necessary configuration data as required by commit-boost

# Chain configuration
chain = "{chain}"

# PBS configuration
[pbs]
port = 18850
with_signer = true

# Relays configuration (required by commit-boost config structure)
[[relays]]
url = "https://0xafa4c6985aa049fb79dd37010438cfebeb0f2bd42b115b89dd678dab0670c1de38da0c4e9138c9290a398ecd9a0b3110@boost-relay-hoodi.flashbots.net"

# Metrics configuration
[metrics]
enabled = true

# Signer configuration
[signer]
port = {port}

[signer.local.loader]
format = "lighthouse"
keys_path = "{keys_path}"
secrets_path = "{secrets_path}"

[signer.local.store]
proxy_dir = "{proxy_key_dir}"

# Gateway Module configuration
[[modules]]
id = "{gateway_module_name}"
signing_id = "{gateway_module_signing_id}"
type = "commit"
docker_image = "n/a"
env_file = "n/a"

# Proposer Module configuration
[[modules]]
id = "{proposer_module_name}"
signing_id = "{proposer_module_signing_id}"
type = "commit"
docker_image = "n/a"
env_file = "n/a"
		"#,
            chain = self.chain,
            port = self.signer_port,
            keys_path = self.keys_path,
            secrets_path = self.secrets_path,
            proxy_key_dir = self.proxy_key_dir,
            gateway_module_name = self.gateway_module_name,
            gateway_module_signing_id = self.gateway_module_signing_id,
            proposer_module_name = self.proposer_module_name,
            proposer_module_signing_id = self.proposer_module_signing_id,
        )
    }

    pub fn write_signer_config(&self, env_state: &SimulationEnv) {
        // Simply use the default cb_config
        let doc = self
            .cb_config()
            .parse::<DocumentMut>()
            .expect("invalid signer toml");
        std::fs::write(env_state.signer_cb_config.clone().unwrap(), doc.to_string())
            .expect("Failed to write signer config");
    }

    pub fn write_gateway_config(&self, env_state: &SimulationEnv) {
        // Start with the default cb_config
        let mut doc = self.cb_config();

        // Append on gateway specific configuration needed for GatewayConfig
        doc.push_str(&format!(
            r#"
# -- Commitments server configuration --

# Address of the Commitments RPC server
rpc_host = "{rpc_host}"

# Port of the Commitments RPC server
rpc_port = "{rpc_port}"

# Host of the metrics server
metrics_host = "{metrics_host}"

# Port of the metrics server
metrics_port = "{metrics_port}"

# Path to the rocksdb database file location
db_path = "{db_path}"

# Host of the Relay server (constraints API)
relay_host = "{relay_host}"

# Port of the Relay server (constraints API)
relay_port = "{relay_port}"

# Execution client configuration
execution_client_host = "{execution_client_host}"
execution_client_port = "{execution_client_port}"

# Constraints receivers (set to gateway BLS proxy key for now)
constraints_receivers = ["{constraints_receivers}"]

# Module signing ID for this gateway instance
module_signing_id = "{module_signing_id}"

# Commitments-specific configuration
log_level = "info"

# How often to check for new delegations
delegation_check_interval_seconds = "{delegation_check_interval_seconds}"

# Gateway public key for signing constraints
gateway_public_key = "{gateway_public_key}"
"#,
            rpc_host = self.gateway_host,
            rpc_port = self.gateway_port,
            metrics_host = self.gateway_metrics_host,
            metrics_port = self.gateway_metrics_port,
            db_path = format!("{}/gateway", self.db_path),
            relay_host = self.relay_host,
            relay_port = self.relay_port,
            execution_client_host = self.execution_client_host,
            execution_client_port = self.execution_client_port,
            constraints_receivers = env_state
                .gateway_bls_proxy
                .clone()
                .expect("gateway BLS proxy key not set"),
            module_signing_id = self.gateway_module_signing_id,
            delegation_check_interval_seconds = self.delegation_check_interval_seconds,
            gateway_public_key = self.gateway_default_bls_key
        ));

        let toml = doc.parse::<DocumentMut>().expect("invalid gateway toml");

        std::fs::write(
            env_state.gateway_cb_config.clone().unwrap(),
            toml.to_string(),
        )
        .expect("failed to write gateway toml");
    }

    pub fn write_proposer_config(&self, env_state: &SimulationEnv) {
        // Start with the default cb_config
        let mut doc = self.cb_config();

        // Append on proposer specific configuration needed for ProposerConfig
        doc.push_str(&format!(
            r#"
# -- Proposer configuration --

# Path to the rocksdb database file location
db_path = "{db_path}"

# Gateway public key to delegate to
gateway_public_key = "{gateway_public_key}"

# Gateway committer EOA address
gateway_address = "{gateway_address}"

# Host of the Relay server (constraints API)
relay_host = "{relay_host}"

# Port of the Relay server (constraints API)
relay_port = "{relay_port}"

# Host of the Beacon API for fetching proposer duties
beacon_api_host = "{beacon_api_host}"

# Port of the Beacon API for fetching proposer duties
beacon_api_port = "{beacon_api_port}"

# How often to check for new delegations
lookahead_check_interval_seconds = "{lookahead_check_interval_seconds}"

# Module signing ID for this proposer instance
module_signing_id = "{module_signing_id}"
"#,
            db_path = format!("{}/proposer", self.db_path),
            gateway_public_key = env_state
                .gateway_bls_proxy
                .clone()
                .expect("gateway BLS proxy key not set"),
            gateway_address = env_state
                .gateway_committer_address
                .clone()
                .expect("gateway address not set"),
            relay_host = self.relay_host,
            relay_port = self.relay_port,
            beacon_api_host = self.beacon_mock_host,
            beacon_api_port = self.beacon_mock_port,
            lookahead_check_interval_seconds = self.lookahead_check_interval_seconds,
            module_signing_id = self.proposer_module_signing_id
        ));

        let toml = doc.parse::<DocumentMut>().expect("invalid proposer toml");

        std::fs::write(
            env_state.proposer_cb_config.clone().unwrap(),
            toml.to_string(),
        )
        .expect("failed to write proposer toml");
    }

    pub fn write_relay_config(&self, env_state: &SimulationEnv) {
        // Relay specific configuration needed for RelayConfig
        let doc = format!(
            r#"# This file is automatically generated by the simulation-setup binary
# -- Relay configuration --

[relay]
chain = "{chain}"
host = "{relay_host}"
port = "{relay_port}"
db_path = "{db_path}"
constraint_capabilities = [{constraint_capabilities}]
beacon_api_host = "{beacon_api_host}"
beacon_api_port = "{beacon_api_port}"
lookahead_update_interval = "{lookahead_update_interval}"
downstream_relay_url = "{downstream_relay_url}"
log_level = "{log_level}"
"#,
            chain = self.chain,
            relay_host = self.relay_host,
            relay_port = self.relay_port,
            db_path = format!("{}/relay", self.db_path),
            constraint_capabilities = INCLUSION_CONSTRAINT_TYPE,
            beacon_api_host = self.beacon_mock_host,
            beacon_api_port = self.beacon_mock_port,
            lookahead_update_interval = self.lookahead_update_interval,
            downstream_relay_url = self.downstream_relay_url,
            log_level = self.log_level,
        );
        let toml = doc.parse::<DocumentMut>().expect("invalid relay toml");

        std::fs::write(env_state.relay_config.clone().unwrap(), toml.to_string())
            .expect("failed to write relay toml");
    }

    pub fn write_spammer_config(&self, env_state: &SimulationEnv) {
        // Spammer specific configuration needed for SpammerConfig
        let doc = format!(
            r#"# This file is automatically generated by the simulation-setup binary
# -- Spammer configuration --

[spammer]
mode = "{mode}"
chain = "{chain}"
gateway_host = "{gateway_host}"
gateway_port = "{gateway_port}"
interval_secs = "{interval_secs}"
sender_private_key = "{sender_private_key}"
slasher_address = "{slasher_address}"
"#,
            mode = self.spammer_mode,
            chain = self.chain,
            gateway_host = self.gateway_host,
            gateway_port = self.gateway_port,
            interval_secs = self.spammer_interval_secs,
            sender_private_key = self.spammer_private_key,
            slasher_address = self.slasher_address,
        );
        let toml = doc.parse::<DocumentMut>().expect("invalid relay toml");

        std::fs::write(env_state.spammer_config.clone().unwrap(), toml.to_string())
            .expect("failed to write spammer toml");
    }
}

// Generates the simulation environment variables needed by
// commit-boost load_commit_module_config() and StartSignerConfig::load_from_env()? to run proposer / gateway / signer
pub struct SimulationEnv {
    admin_jwt: Option<Jwt>,
    gateway_jwt: Option<Jwt>,
    proposer_jwt: Option<Jwt>,
    gateway_module_id: Option<ModuleId>,
    proposer_module_id: Option<ModuleId>,
    gateway_cb_config: Option<String>,
    proposer_cb_config: Option<String>,
    signer_cb_config: Option<String>,
    relay_config: Option<String>,
    spammer_config: Option<String>,
    gateway_env_file: Option<String>,
    proposer_env_file: Option<String>,
    signer_env_file: Option<String>,
    relay_env_file: Option<String>,
    spammer_env_file: Option<String>,
    signer_url: Option<Url>,
    gateway_bls_proxy: Option<String>,
    gateway_committer_address: Option<String>,
    log_level: Option<String>,
}

impl SimulationEnv {
    pub fn new() -> Self {
        Self {
            admin_jwt: None,
            gateway_jwt: None,
            proposer_jwt: None,
            gateway_module_id: None,
            proposer_module_id: None,
            gateway_cb_config: None,
            proposer_cb_config: None,
            signer_cb_config: None,
            relay_config: None,
            spammer_config: None,
            gateway_env_file: None,
            proposer_env_file: None,
            signer_env_file: None,
            relay_env_file: None,
            spammer_env_file: None,
            signer_url: None,
            gateway_bls_proxy: None,
            gateway_committer_address: None,
            log_level: None,
        }
    }
    pub fn set_jwts(&mut self) -> &mut Self {
        self.gateway_jwt = Some(Jwt(random_jwt_secret()));
        self.proposer_jwt = Some(Jwt(random_jwt_secret()));
        self.admin_jwt = Some(Jwt(random_jwt_secret()));
        self
    }

    pub fn set_module_ids(&mut self, config: &SimulationConfig) -> &mut Self {
        self.gateway_module_id = Some(ModuleId(config.gateway_module_name.clone()));
        self.proposer_module_id = Some(ModuleId(config.proposer_module_name.clone()));
        self
    }

    pub fn set_env_files(&mut self) -> &mut Self {
        self.gateway_env_file = Some(format!(
            "config/simulation/{}.env",
            self.gateway_module_id.clone().unwrap()
        ));
        self.proposer_env_file = Some(format!(
            "config/simulation/{}.env",
            self.proposer_module_id.clone().unwrap()
        ));
        self.signer_env_file = Some(format!("config/simulation/signer.env"));
        self.relay_env_file = Some(format!("config/simulation/relay.env"));
        self.spammer_env_file = Some(format!("config/simulation/spammer.env"));
        self
    }

    pub fn set_signer_url(&mut self, config: &SimulationConfig) -> &mut Self {
        self.signer_url = Some(
            Url::parse(&format!(
                "{host}:{port}",
                host = config.signer_host,
                port = config.signer_port
            ))
            .expect("Failed to parse signer URL"),
        );
        self
    }

    pub fn set_config_paths(&mut self) -> &mut Self {
        self.gateway_cb_config = Some(format!(
            "config/simulation/{}.toml",
            self.gateway_module_id.clone().unwrap()
        ));
        self.proposer_cb_config = Some(format!(
            "config/simulation/{}.toml",
            self.proposer_module_id.clone().unwrap()
        ));
        self.signer_cb_config = Some(format!("config/simulation/signer.toml"));
        self.relay_config = Some(format!("config/simulation/relay.toml"));
        self.spammer_config = Some(format!("config/simulation/spammer.toml"));
        self
    }

    pub fn set_proxy_keys(&mut self, bls_proxy: String, ecdsa_proxy: String) {
        self.gateway_bls_proxy = Some(bls_proxy);
        self.gateway_committer_address = Some(ecdsa_proxy);
    }

    pub fn set_log_level(&mut self, log_level: String) -> &mut Self {
        self.log_level = Some(log_level);
        self
    }

    pub fn write_env_files(&mut self) -> &mut Self {
        // Gateway .env file
        let mut gateway_env_content = String::new();
        gateway_env_content.push_str("# Simulation environment variables\n");
        gateway_env_content.push_str("# Generated by simulation-setup binary\n\n");

        gateway_env_content.push_str(&format!(
            "CB_CONFIG={}\n",
            self.gateway_cb_config.clone().unwrap()
        ));
        gateway_env_content.push_str(&format!(
            "CB_MODULE_ID={}\n",
            self.gateway_module_id.clone().unwrap()
        ));
        gateway_env_content.push_str(&format!(
            "CB_SIGNER_JWT={}\n",
            self.gateway_jwt.clone().unwrap()
        ));
        gateway_env_content.push_str(&format!(
            "CB_SIGNER_URL={}\n",
            self.signer_url.clone().unwrap()
        ));
        gateway_env_content.push_str(&format!("RUST_LOG={}\n", self.log_level.clone().unwrap()));

        std::fs::write(&self.gateway_env_file.clone().unwrap(), gateway_env_content)
            .expect("Failed to write gateway .env file");

        // Proposer .env file
        let mut proposer_env_content = String::new();
        proposer_env_content.push_str("# Simulation environment variables\n");
        proposer_env_content.push_str("# Generated by simulation-setup binary\n\n");

        proposer_env_content.push_str(&format!(
            "CB_CONFIG={}\n",
            self.proposer_cb_config.clone().unwrap()
        ));
        proposer_env_content.push_str(&format!(
            "CB_MODULE_ID={}\n",
            self.proposer_module_id.clone().unwrap()
        ));
        proposer_env_content.push_str(&format!(
            "CB_SIGNER_JWT={}\n",
            self.proposer_jwt.clone().unwrap()
        ));
        proposer_env_content.push_str(&format!(
            "CB_SIGNER_URL={}\n",
            self.signer_url.clone().unwrap()
        ));
        proposer_env_content.push_str(&format!("RUST_LOG={}\n", self.log_level.clone().unwrap()));

        std::fs::write(
            &self.proposer_env_file.clone().unwrap(),
            proposer_env_content,
        )
        .expect("Failed to write proposer .env file");

        // Signer .env file
        let mut signer_env_content = String::new();
        signer_env_content.push_str("# Simulation environment variables\n");
        signer_env_content.push_str("# Generated by simulation-setup binary\n\n");

        let cb_jwts = format!(
            "{gateway_module_id}={gateway_jwt},{proposer_module_id}={proposer_jwt}",
            gateway_module_id = self.gateway_module_id.clone().unwrap(),
            gateway_jwt = self.gateway_jwt.clone().unwrap(),
            proposer_module_id = self.proposer_module_id.clone().unwrap(),
            proposer_jwt = self.proposer_jwt.clone().unwrap()
        );

        signer_env_content.push_str(&format!(
            "CB_CONFIG={cb_config}\n",
            cb_config = self.signer_cb_config.clone().unwrap()
        ));
        signer_env_content.push_str(&format!("CB_JWTS={cb_jwts}\n", cb_jwts = cb_jwts));
        signer_env_content.push_str(&format!(
            "CB_SIGNER_ADMIN_JWT={}\n",
            self.admin_jwt.clone().unwrap()
        ));
        signer_env_content.push_str(&format!("RUST_LOG={}\n", self.log_level.clone().unwrap()));

        std::fs::write(&self.signer_env_file.clone().unwrap(), signer_env_content)
            .expect("Failed to write signer .env file");

        // Relay .env file
        let mut relay_env_content = String::new();
        relay_env_content.push_str("# Simulation environment variables\n");
        relay_env_content.push_str("# Generated by simulation-setup binary\n\n");

        relay_env_content.push_str(&format!(
            "CONFIG_PATH={}\n",
            self.relay_config.clone().unwrap()
        ));
        relay_env_content.push_str(&format!("RUST_LOG={}\n", self.log_level.clone().unwrap()));

        std::fs::write(&self.relay_env_file.clone().unwrap(), relay_env_content)
            .expect("Failed to write relay .env file");

        // Spammer .env file
        let mut spammer_env_content = String::new();
        spammer_env_content.push_str("# Simulation environment variables\n");
        spammer_env_content.push_str("# Generated by simulation-setup binary\n\n");

        spammer_env_content.push_str(&format!(
            "CONFIG_PATH={}\n",
            self.spammer_config.clone().unwrap()
        ));
        spammer_env_content.push_str(&format!("RUST_LOG={}\n", self.log_level.clone().unwrap()));

        std::fs::write(&self.spammer_env_file.clone().unwrap(), spammer_env_content)
            .expect("Failed to write spammer .env file");

        self
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    tracing_subscriber::fmt::init();
    info!("Starting simulation setup");

    // Load configuration
    let config = SimulationConfig::new("config/simulation.config.toml")?;
    println!("Config: {:?}", config);

    // Setup directories
    config.setup_directories()?;

    let mut env_state = SimulationEnv::new();
    env_state
        .set_module_ids(&config)
        .set_log_level(config.log_level.clone())
        .set_jwts()
        .set_signer_url(&config)
        .set_config_paths()
        .set_env_files()
        .write_env_files();

    // Generate cb signer config
    config.write_signer_config(&env_state);

    // Load cb signer config using commit-boost config structure
    let signer_config = config.load_cb_signer_config(&env_state).await?;
    println!("Signer config: {:?}", signer_config);

    // Launch a local signer server
    let signer_server_handle =
        tokio::spawn(async move { SigningService::run(signer_config).await });

    // Wait for signer server to start
    sleep(std::time::Duration::from_secs(5)).await;

    // Make requests to signer server to generate proxy keys
    let (bls_proxy, ecdsa_proxy) = config.generate_gateway_proxy_keys(&env_state).await?;

    // Kill signer server
    signer_server_handle.abort();

    // Save proxy keys to env_state
    env_state.set_proxy_keys(bls_proxy.to_string(), ecdsa_proxy.to_string());

    // Write gateway config
    config.write_gateway_config(&env_state);

    // Write proposer config
    config.write_proposer_config(&env_state);

    // Write relay config
    config.write_relay_config(&env_state);

    // Write spammer config
	config.write_spammer_config(&env_state);

    Ok(())
}
